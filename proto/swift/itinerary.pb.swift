// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: itinerary.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Com_Infinite_Travllr_ActivityCategory: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case foodAndNightlife // = 0
  case leisureAndNature // = 1
  case waterSportsAndCruises // = 2
  case adventureAndOutdoor // = 3
  case artAndArchitecture // = 4
  case attractionsAndCulture // = 5
  case bestOfAll // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .foodAndNightlife
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .foodAndNightlife
    case 1: self = .leisureAndNature
    case 2: self = .waterSportsAndCruises
    case 3: self = .adventureAndOutdoor
    case 4: self = .artAndArchitecture
    case 5: self = .attractionsAndCulture
    case 6: self = .bestOfAll
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .foodAndNightlife: return 0
    case .leisureAndNature: return 1
    case .waterSportsAndCruises: return 2
    case .adventureAndOutdoor: return 3
    case .artAndArchitecture: return 4
    case .attractionsAndCulture: return 5
    case .bestOfAll: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

enum Com_Infinite_Travllr_ActivityType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case activity // = 0
  case intercityTransfer // = 1
  case internationalArrival // = 2
  case internationalDeparture // = 3
  case leisure // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .activity
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .activity
    case 1: self = .intercityTransfer
    case 2: self = .internationalArrival
    case 3: self = .internationalDeparture
    case 4: self = .leisure
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .activity: return 0
    case .intercityTransfer: return 1
    case .internationalArrival: return 2
    case .internationalDeparture: return 3
    case .leisure: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

enum Com_Infinite_Travllr_ActivityDuration: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case fullDay // = 0
  case morning // = 1
  case noon // = 2
  case evening // = 3
  case morningToNoon // = 4
  case noonToEvening // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .fullDay
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .fullDay
    case 1: self = .morning
    case 2: self = .noon
    case 3: self = .evening
    case 4: self = .morningToNoon
    case 5: self = .noonToEvening
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .fullDay: return 0
    case .morning: return 1
    case .noon: return 2
    case .evening: return 3
    case .morningToNoon: return 4
    case .noonToEvening: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

enum Com_Infinite_Travllr_TransferType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case ferry // = 0
  case fly // = 1
  case train // = 2
  case cab // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .ferry
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ferry
    case 1: self = .fly
    case 2: self = .train
    case 3: self = .cab
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .ferry: return 0
    case .fly: return 1
    case .train: return 2
    case .cab: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

struct Com_Infinite_Travllr_ItineraryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var country: [String] = []

  var city: [String] = []

  var regionName: String = String()

  var numberOfDays: Int32 = 0

  var activityCategory: [Com_Infinite_Travllr_ActivityCategory] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Infinite_Travllr_ItineraryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cityPlan: [Com_Infinite_Travllr_CityPlan] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Infinite_Travllr_CityPlan {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cityName: String = String()

  var numberOfNights: Int32 = 0

  var dayPlan: [Com_Infinite_Travllr_DayPlan] = []

  var transferTimeInMinutes: Int32 = 0

  var transferType: Com_Infinite_Travllr_TransferType = .ferry

  var latitudeLocation: Float = 0

  var longitudeLocation: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Infinite_Travllr_DayPlan {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var activityDetail: [Com_Infinite_Travllr_ActivityDetail] = []

  var transferType: Com_Infinite_Travllr_TransferType = .ferry

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Infinite_Travllr_ActivityDetail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var activityType: Com_Infinite_Travllr_ActivityType = .activity

  var name: String = String()

  var description_p: String = String()

  var imgURL: String = String()

  var activityDuration: Com_Infinite_Travllr_ActivityDuration = .fullDay

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.infinite.travllr"

extension Com_Infinite_Travllr_ActivityCategory: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FOOD_AND_NIGHTLIFE"),
    1: .same(proto: "LEISURE_AND_NATURE"),
    2: .same(proto: "WATER_SPORTS_AND_CRUISES"),
    3: .same(proto: "ADVENTURE_AND_OUTDOOR"),
    4: .same(proto: "ART_AND_ARCHITECTURE"),
    5: .same(proto: "ATTRACTIONS_AND_CULTURE"),
    6: .same(proto: "BEST_OF_ALL"),
  ]
}

extension Com_Infinite_Travllr_ActivityType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ACTIVITY"),
    1: .same(proto: "INTERCITY_TRANSFER"),
    2: .same(proto: "INTERNATIONAL_ARRIVAL"),
    3: .same(proto: "INTERNATIONAL_DEPARTURE"),
    4: .same(proto: "LEISURE"),
  ]
}

extension Com_Infinite_Travllr_ActivityDuration: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FULL_DAY"),
    1: .same(proto: "MORNING"),
    2: .same(proto: "NOON"),
    3: .same(proto: "EVENING"),
    4: .same(proto: "MORNING_TO_NOON"),
    5: .same(proto: "NOON_TO_EVENING"),
  ]
}

extension Com_Infinite_Travllr_TransferType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FERRY"),
    1: .same(proto: "FLY"),
    2: .same(proto: "TRAIN"),
    3: .same(proto: "CAB"),
  ]
}

extension Com_Infinite_Travllr_ItineraryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ItineraryRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "country"),
    2: .same(proto: "city"),
    3: .same(proto: "regionName"),
    4: .same(proto: "numberOfDays"),
    5: .same(proto: "activityCategory"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.country)
      case 2: try decoder.decodeRepeatedStringField(value: &self.city)
      case 3: try decoder.decodeSingularStringField(value: &self.regionName)
      case 4: try decoder.decodeSingularInt32Field(value: &self.numberOfDays)
      case 5: try decoder.decodeRepeatedEnumField(value: &self.activityCategory)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.country.isEmpty {
      try visitor.visitRepeatedStringField(value: self.country, fieldNumber: 1)
    }
    if !self.city.isEmpty {
      try visitor.visitRepeatedStringField(value: self.city, fieldNumber: 2)
    }
    if !self.regionName.isEmpty {
      try visitor.visitSingularStringField(value: self.regionName, fieldNumber: 3)
    }
    if self.numberOfDays != 0 {
      try visitor.visitSingularInt32Field(value: self.numberOfDays, fieldNumber: 4)
    }
    if !self.activityCategory.isEmpty {
      try visitor.visitPackedEnumField(value: self.activityCategory, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Com_Infinite_Travllr_ItineraryRequest) -> Bool {
    if self.country != other.country {return false}
    if self.city != other.city {return false}
    if self.regionName != other.regionName {return false}
    if self.numberOfDays != other.numberOfDays {return false}
    if self.activityCategory != other.activityCategory {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Com_Infinite_Travllr_ItineraryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ItineraryResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cityPlan"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.cityPlan)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cityPlan.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cityPlan, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Com_Infinite_Travllr_ItineraryResponse) -> Bool {
    if self.cityPlan != other.cityPlan {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Com_Infinite_Travllr_CityPlan: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CityPlan"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cityName"),
    2: .same(proto: "numberOfNights"),
    3: .same(proto: "dayPlan"),
    4: .same(proto: "transferTimeInMinutes"),
    5: .same(proto: "transferType"),
    6: .same(proto: "latitudeLocation"),
    7: .same(proto: "longitudeLocation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.cityName)
      case 2: try decoder.decodeSingularInt32Field(value: &self.numberOfNights)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.dayPlan)
      case 4: try decoder.decodeSingularInt32Field(value: &self.transferTimeInMinutes)
      case 5: try decoder.decodeSingularEnumField(value: &self.transferType)
      case 6: try decoder.decodeSingularFloatField(value: &self.latitudeLocation)
      case 7: try decoder.decodeSingularFloatField(value: &self.longitudeLocation)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cityName.isEmpty {
      try visitor.visitSingularStringField(value: self.cityName, fieldNumber: 1)
    }
    if self.numberOfNights != 0 {
      try visitor.visitSingularInt32Field(value: self.numberOfNights, fieldNumber: 2)
    }
    if !self.dayPlan.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dayPlan, fieldNumber: 3)
    }
    if self.transferTimeInMinutes != 0 {
      try visitor.visitSingularInt32Field(value: self.transferTimeInMinutes, fieldNumber: 4)
    }
    if self.transferType != .ferry {
      try visitor.visitSingularEnumField(value: self.transferType, fieldNumber: 5)
    }
    if self.latitudeLocation != 0 {
      try visitor.visitSingularFloatField(value: self.latitudeLocation, fieldNumber: 6)
    }
    if self.longitudeLocation != 0 {
      try visitor.visitSingularFloatField(value: self.longitudeLocation, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Com_Infinite_Travllr_CityPlan) -> Bool {
    if self.cityName != other.cityName {return false}
    if self.numberOfNights != other.numberOfNights {return false}
    if self.dayPlan != other.dayPlan {return false}
    if self.transferTimeInMinutes != other.transferTimeInMinutes {return false}
    if self.transferType != other.transferType {return false}
    if self.latitudeLocation != other.latitudeLocation {return false}
    if self.longitudeLocation != other.longitudeLocation {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Com_Infinite_Travllr_DayPlan: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DayPlan"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "activityDetail"),
    2: .same(proto: "transferType"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.activityDetail)
      case 2: try decoder.decodeSingularEnumField(value: &self.transferType)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.activityDetail.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.activityDetail, fieldNumber: 1)
    }
    if self.transferType != .ferry {
      try visitor.visitSingularEnumField(value: self.transferType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Com_Infinite_Travllr_DayPlan) -> Bool {
    if self.activityDetail != other.activityDetail {return false}
    if self.transferType != other.transferType {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Com_Infinite_Travllr_ActivityDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivityDetail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "activityType"),
    2: .same(proto: "name"),
    3: .same(proto: "description"),
    4: .same(proto: "imgUrl"),
    5: .same(proto: "activityDuration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.activityType)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularStringField(value: &self.description_p)
      case 4: try decoder.decodeSingularStringField(value: &self.imgURL)
      case 5: try decoder.decodeSingularEnumField(value: &self.activityDuration)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.activityType != .activity {
      try visitor.visitSingularEnumField(value: self.activityType, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.imgURL.isEmpty {
      try visitor.visitSingularStringField(value: self.imgURL, fieldNumber: 4)
    }
    if self.activityDuration != .fullDay {
      try visitor.visitSingularEnumField(value: self.activityDuration, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Com_Infinite_Travllr_ActivityDetail) -> Bool {
    if self.activityType != other.activityType {return false}
    if self.name != other.name {return false}
    if self.description_p != other.description_p {return false}
    if self.imgURL != other.imgURL {return false}
    if self.activityDuration != other.activityDuration {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
