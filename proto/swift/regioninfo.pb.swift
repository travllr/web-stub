// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: regioninfo.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Com_Infinite_Travllr_RegionInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var countryCode: String = String()

  var regionName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Infinite_Travllr_RegionInfoUpdateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var countryCode: [String] = []

  var regionName: String = String()

  var countries: [String] = []

  var weatherInfo: [Com_Infinite_Travllr_WeatherInfo] = []

  var itineraryRoutes: [Com_Infinite_Travllr_ItineraryRoutes] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Infinite_Travllr_RegionInfoUpdateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Infinite_Travllr_CityRouteInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transferInfo: Com_Infinite_Travllr_CityRouteInfo.TransferType {
    get {return _storage._transferInfo}
    set {_uniqueStorage()._transferInfo = newValue}
  }

  var noOfDays: Int32 {
    get {return _storage._noOfDays}
    set {_uniqueStorage()._noOfDays = newValue}
  }

  var city: Com_Infinite_Travllr_CityDetail {
    get {return _storage._city ?? Com_Infinite_Travllr_CityDetail()}
    set {_uniqueStorage()._city = newValue}
  }
  /// Returns true if `city` has been explicitly set.
  var hasCity: Bool {return _storage._city != nil}
  /// Clears the value of `city`. Subsequent reads from it will return its default value.
  mutating func clearCity() {_storage._city = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TransferType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ferry // = 0
    case fly // = 1
    case train // = 2
    case cab // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .ferry
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ferry
      case 1: self = .fly
      case 2: self = .train
      case 3: self = .cab
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .ferry: return 0
      case .fly: return 1
      case .train: return 2
      case .cab: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Com_Infinite_Travllr_ItineraryRoutes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var durationInfo: Com_Infinite_Travllr_DurationInfo {
    get {return _storage._durationInfo ?? Com_Infinite_Travllr_DurationInfo()}
    set {_uniqueStorage()._durationInfo = newValue}
  }
  /// Returns true if `durationInfo` has been explicitly set.
  var hasDurationInfo: Bool {return _storage._durationInfo != nil}
  /// Clears the value of `durationInfo`. Subsequent reads from it will return its default value.
  mutating func clearDurationInfo() {_storage._durationInfo = nil}

  var cityRoutes: [Com_Infinite_Travllr_CityRouteInfo] {
    get {return _storage._cityRoutes}
    set {_uniqueStorage()._cityRoutes = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Com_Infinite_Travllr_RegionInfoSaveRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var countryCode: [String] = []

  var regionName: String = String()

  var countries: [String] = []

  var weatherInfo: [Com_Infinite_Travllr_WeatherInfo] = []

  var itineraryRoutes: [Com_Infinite_Travllr_ItineraryRoutes] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Infinite_Travllr_RegionInfoSaveResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Infinite_Travllr_RegionInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var countryCode: [String] = []

  var regionName: String = String()

  var weatherInfo: [Com_Infinite_Travllr_WeatherInfo] = []

  var itineraryRoutes: [Com_Infinite_Travllr_ItineraryRoutes] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Infinite_Travllr_WeatherInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var month: String = String()

  var minTemp: Float = 0

  var maxTemp: Float = 0

  var season: Com_Infinite_Travllr_WeatherInfo.Season = .ourPick

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Season: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ourPick // = 0
    case secondBest // = 1
    case offSeason // = 2
    case tooCrowded // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .ourPick
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ourPick
      case 1: self = .secondBest
      case 2: self = .offSeason
      case 3: self = .tooCrowded
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .ourPick: return 0
      case .secondBest: return 1
      case .offSeason: return 2
      case .tooCrowded: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

struct Com_Infinite_Travllr_DurationInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var popular: Bool = false

  var minimumDays: Int32 = 0

  var maximumDays: Int32 = 0

  var recommended: Bool = false

  var size: Com_Infinite_Travllr_DurationInfo.PackageSize = .small

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum PackageSize: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case small // = 0
    case medium // = 1
    case large // = 2
    case extraLarge // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .small
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .small
      case 1: self = .medium
      case 2: self = .large
      case 3: self = .extraLarge
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .small: return 0
      case .medium: return 1
      case .large: return 2
      case .extraLarge: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

struct Com_Infinite_Travllr_RegionListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var countryCode: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Infinite_Travllr_RegionListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var regions: [Com_Infinite_Travllr_RegionInfoResponse] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Infinite_Travllr_RegionDeleteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Infinite_Travllr_RegionDeleteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Infinite_Travllr_CityListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var countries: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Infinite_Travllr_AirportDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: String {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var city: String {
    get {return _storage._city}
    set {_uniqueStorage()._city = newValue}
  }

  var country: String {
    get {return _storage._country}
    set {_uniqueStorage()._country = newValue}
  }

  var point: Com_Infinite_Travllr_AirportLocationDetail {
    get {return _storage._point ?? Com_Infinite_Travllr_AirportLocationDetail()}
    set {_uniqueStorage()._point = newValue}
  }
  /// Returns true if `point` has been explicitly set.
  var hasPoint: Bool {return _storage._point != nil}
  /// Clears the value of `point`. Subsequent reads from it will return its default value.
  mutating func clearPoint() {_storage._point = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Com_Infinite_Travllr_AirportLocationDetail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: String = String()

  var coordinates: [Double] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Infinite_Travllr_AirportInsertRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var countryCode: String = String()

  var cityName: String = String()

  var airports: [Com_Infinite_Travllr_AirportDetails] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Infinite_Travllr_AirportInsertResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Infinite_Travllr_CityLocationDetail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: String = String()

  var coordinates: [Double] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Com_Infinite_Travllr_CityDetail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var country: String {
    get {return _storage._country}
    set {_uniqueStorage()._country = newValue}
  }

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var point: Com_Infinite_Travllr_CityLocationDetail {
    get {return _storage._point ?? Com_Infinite_Travllr_CityLocationDetail()}
    set {_uniqueStorage()._point = newValue}
  }
  /// Returns true if `point` has been explicitly set.
  var hasPoint: Bool {return _storage._point != nil}
  /// Clears the value of `point`. Subsequent reads from it will return its default value.
  mutating func clearPoint() {_storage._point = nil}

  var airports: [Com_Infinite_Travllr_AirportDetails] {
    get {return _storage._airports}
    set {_uniqueStorage()._airports = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Com_Infinite_Travllr_CityListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cities: [Com_Infinite_Travllr_CityDetail] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.infinite.travllr"

extension Com_Infinite_Travllr_RegionInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegionInfoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "countryCode"),
    2: .same(proto: "regionName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.countryCode)
      case 2: try decoder.decodeSingularStringField(value: &self.regionName)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.countryCode.isEmpty {
      try visitor.visitSingularStringField(value: self.countryCode, fieldNumber: 1)
    }
    if !self.regionName.isEmpty {
      try visitor.visitSingularStringField(value: self.regionName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Com_Infinite_Travllr_RegionInfoRequest) -> Bool {
    if self.countryCode != other.countryCode {return false}
    if self.regionName != other.regionName {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Com_Infinite_Travllr_RegionInfoUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegionInfoUpdateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "countryCode"),
    3: .same(proto: "regionName"),
    4: .same(proto: "countries"),
    5: .same(proto: "weatherInfo"),
    6: .same(proto: "itineraryRoutes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeRepeatedStringField(value: &self.countryCode)
      case 3: try decoder.decodeSingularStringField(value: &self.regionName)
      case 4: try decoder.decodeRepeatedStringField(value: &self.countries)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.weatherInfo)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.itineraryRoutes)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.countryCode.isEmpty {
      try visitor.visitRepeatedStringField(value: self.countryCode, fieldNumber: 2)
    }
    if !self.regionName.isEmpty {
      try visitor.visitSingularStringField(value: self.regionName, fieldNumber: 3)
    }
    if !self.countries.isEmpty {
      try visitor.visitRepeatedStringField(value: self.countries, fieldNumber: 4)
    }
    if !self.weatherInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.weatherInfo, fieldNumber: 5)
    }
    if !self.itineraryRoutes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.itineraryRoutes, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Com_Infinite_Travllr_RegionInfoUpdateRequest) -> Bool {
    if self.id != other.id {return false}
    if self.countryCode != other.countryCode {return false}
    if self.regionName != other.regionName {return false}
    if self.countries != other.countries {return false}
    if self.weatherInfo != other.weatherInfo {return false}
    if self.itineraryRoutes != other.itineraryRoutes {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Com_Infinite_Travllr_RegionInfoUpdateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegionInfoUpdateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.status)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != false {
      try visitor.visitSingularBoolField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Com_Infinite_Travllr_RegionInfoUpdateResponse) -> Bool {
    if self.status != other.status {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Com_Infinite_Travllr_CityRouteInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CityRouteInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transferInfo"),
    2: .same(proto: "noOfDays"),
    3: .same(proto: "city"),
  ]

  fileprivate class _StorageClass {
    var _transferInfo: Com_Infinite_Travllr_CityRouteInfo.TransferType = .ferry
    var _noOfDays: Int32 = 0
    var _city: Com_Infinite_Travllr_CityDetail? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _transferInfo = source._transferInfo
      _noOfDays = source._noOfDays
      _city = source._city
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._transferInfo)
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._noOfDays)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._city)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._transferInfo != .ferry {
        try visitor.visitSingularEnumField(value: _storage._transferInfo, fieldNumber: 1)
      }
      if _storage._noOfDays != 0 {
        try visitor.visitSingularInt32Field(value: _storage._noOfDays, fieldNumber: 2)
      }
      if let v = _storage._city {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Com_Infinite_Travllr_CityRouteInfo) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._transferInfo != other_storage._transferInfo {return false}
        if _storage._noOfDays != other_storage._noOfDays {return false}
        if _storage._city != other_storage._city {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Com_Infinite_Travllr_CityRouteInfo.TransferType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FERRY"),
    1: .same(proto: "FLY"),
    2: .same(proto: "TRAIN"),
    3: .same(proto: "CAB"),
  ]
}

extension Com_Infinite_Travllr_ItineraryRoutes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ItineraryRoutes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "durationInfo"),
    2: .same(proto: "cityRoutes"),
  ]

  fileprivate class _StorageClass {
    var _durationInfo: Com_Infinite_Travllr_DurationInfo? = nil
    var _cityRoutes: [Com_Infinite_Travllr_CityRouteInfo] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _durationInfo = source._durationInfo
      _cityRoutes = source._cityRoutes
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._durationInfo)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._cityRoutes)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._durationInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._cityRoutes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._cityRoutes, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Com_Infinite_Travllr_ItineraryRoutes) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._durationInfo != other_storage._durationInfo {return false}
        if _storage._cityRoutes != other_storage._cityRoutes {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Com_Infinite_Travllr_RegionInfoSaveRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegionInfoSaveRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "countryCode"),
    2: .same(proto: "regionName"),
    3: .same(proto: "countries"),
    4: .same(proto: "weatherInfo"),
    5: .same(proto: "itineraryRoutes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.countryCode)
      case 2: try decoder.decodeSingularStringField(value: &self.regionName)
      case 3: try decoder.decodeRepeatedStringField(value: &self.countries)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.weatherInfo)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.itineraryRoutes)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.countryCode.isEmpty {
      try visitor.visitRepeatedStringField(value: self.countryCode, fieldNumber: 1)
    }
    if !self.regionName.isEmpty {
      try visitor.visitSingularStringField(value: self.regionName, fieldNumber: 2)
    }
    if !self.countries.isEmpty {
      try visitor.visitRepeatedStringField(value: self.countries, fieldNumber: 3)
    }
    if !self.weatherInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.weatherInfo, fieldNumber: 4)
    }
    if !self.itineraryRoutes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.itineraryRoutes, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Com_Infinite_Travllr_RegionInfoSaveRequest) -> Bool {
    if self.countryCode != other.countryCode {return false}
    if self.regionName != other.regionName {return false}
    if self.countries != other.countries {return false}
    if self.weatherInfo != other.weatherInfo {return false}
    if self.itineraryRoutes != other.itineraryRoutes {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Com_Infinite_Travllr_RegionInfoSaveResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegionInfoSaveResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.status)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != false {
      try visitor.visitSingularBoolField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Com_Infinite_Travllr_RegionInfoSaveResponse) -> Bool {
    if self.status != other.status {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Com_Infinite_Travllr_RegionInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegionInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "countryCode"),
    3: .same(proto: "regionName"),
    4: .same(proto: "weatherInfo"),
    5: .same(proto: "itineraryRoutes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeRepeatedStringField(value: &self.countryCode)
      case 3: try decoder.decodeSingularStringField(value: &self.regionName)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.weatherInfo)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.itineraryRoutes)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.countryCode.isEmpty {
      try visitor.visitRepeatedStringField(value: self.countryCode, fieldNumber: 2)
    }
    if !self.regionName.isEmpty {
      try visitor.visitSingularStringField(value: self.regionName, fieldNumber: 3)
    }
    if !self.weatherInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.weatherInfo, fieldNumber: 4)
    }
    if !self.itineraryRoutes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.itineraryRoutes, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Com_Infinite_Travllr_RegionInfoResponse) -> Bool {
    if self.id != other.id {return false}
    if self.countryCode != other.countryCode {return false}
    if self.regionName != other.regionName {return false}
    if self.weatherInfo != other.weatherInfo {return false}
    if self.itineraryRoutes != other.itineraryRoutes {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Com_Infinite_Travllr_WeatherInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WeatherInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "month"),
    2: .same(proto: "minTemp"),
    3: .same(proto: "maxTemp"),
    4: .same(proto: "season"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.month)
      case 2: try decoder.decodeSingularFloatField(value: &self.minTemp)
      case 3: try decoder.decodeSingularFloatField(value: &self.maxTemp)
      case 4: try decoder.decodeSingularEnumField(value: &self.season)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.month.isEmpty {
      try visitor.visitSingularStringField(value: self.month, fieldNumber: 1)
    }
    if self.minTemp != 0 {
      try visitor.visitSingularFloatField(value: self.minTemp, fieldNumber: 2)
    }
    if self.maxTemp != 0 {
      try visitor.visitSingularFloatField(value: self.maxTemp, fieldNumber: 3)
    }
    if self.season != .ourPick {
      try visitor.visitSingularEnumField(value: self.season, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Com_Infinite_Travllr_WeatherInfo) -> Bool {
    if self.month != other.month {return false}
    if self.minTemp != other.minTemp {return false}
    if self.maxTemp != other.maxTemp {return false}
    if self.season != other.season {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Com_Infinite_Travllr_WeatherInfo.Season: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OUR_PICK"),
    1: .same(proto: "SECOND_BEST"),
    2: .same(proto: "OFF_SEASON"),
    3: .same(proto: "TOO_CROWDED"),
  ]
}

extension Com_Infinite_Travllr_DurationInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DurationInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "popular"),
    2: .same(proto: "minimumDays"),
    3: .same(proto: "maximumDays"),
    4: .same(proto: "recommended"),
    5: .same(proto: "size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.popular)
      case 2: try decoder.decodeSingularInt32Field(value: &self.minimumDays)
      case 3: try decoder.decodeSingularInt32Field(value: &self.maximumDays)
      case 4: try decoder.decodeSingularBoolField(value: &self.recommended)
      case 5: try decoder.decodeSingularEnumField(value: &self.size)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.popular != false {
      try visitor.visitSingularBoolField(value: self.popular, fieldNumber: 1)
    }
    if self.minimumDays != 0 {
      try visitor.visitSingularInt32Field(value: self.minimumDays, fieldNumber: 2)
    }
    if self.maximumDays != 0 {
      try visitor.visitSingularInt32Field(value: self.maximumDays, fieldNumber: 3)
    }
    if self.recommended != false {
      try visitor.visitSingularBoolField(value: self.recommended, fieldNumber: 4)
    }
    if self.size != .small {
      try visitor.visitSingularEnumField(value: self.size, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Com_Infinite_Travllr_DurationInfo) -> Bool {
    if self.popular != other.popular {return false}
    if self.minimumDays != other.minimumDays {return false}
    if self.maximumDays != other.maximumDays {return false}
    if self.recommended != other.recommended {return false}
    if self.size != other.size {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Com_Infinite_Travllr_DurationInfo.PackageSize: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SMALL"),
    1: .same(proto: "MEDIUM"),
    2: .same(proto: "LARGE"),
    3: .same(proto: "EXTRA_LARGE"),
  ]
}

extension Com_Infinite_Travllr_RegionListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegionListRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "countryCode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.countryCode)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.countryCode.isEmpty {
      try visitor.visitRepeatedStringField(value: self.countryCode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Com_Infinite_Travllr_RegionListRequest) -> Bool {
    if self.countryCode != other.countryCode {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Com_Infinite_Travllr_RegionListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegionListResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "regions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.regions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.regions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.regions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Com_Infinite_Travllr_RegionListResponse) -> Bool {
    if self.regions != other.regions {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Com_Infinite_Travllr_RegionDeleteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegionDeleteRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Com_Infinite_Travllr_RegionDeleteRequest) -> Bool {
    if self.id != other.id {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Com_Infinite_Travllr_RegionDeleteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegionDeleteResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "response"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.response)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.response != false {
      try visitor.visitSingularBoolField(value: self.response, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Com_Infinite_Travllr_RegionDeleteResponse) -> Bool {
    if self.response != other.response {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Com_Infinite_Travllr_CityListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CityListRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "countries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.countries)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.countries.isEmpty {
      try visitor.visitRepeatedStringField(value: self.countries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Com_Infinite_Travllr_CityListRequest) -> Bool {
    if self.countries != other.countries {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Com_Infinite_Travllr_AirportDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AirportDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "name"),
    3: .same(proto: "city"),
    4: .same(proto: "country"),
    5: .same(proto: "point"),
  ]

  fileprivate class _StorageClass {
    var _code: String = String()
    var _name: String = String()
    var _city: String = String()
    var _country: String = String()
    var _point: Com_Infinite_Travllr_AirportLocationDetail? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _code = source._code
      _name = source._name
      _city = source._city
      _country = source._country
      _point = source._point
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._code)
        case 2: try decoder.decodeSingularStringField(value: &_storage._name)
        case 3: try decoder.decodeSingularStringField(value: &_storage._city)
        case 4: try decoder.decodeSingularStringField(value: &_storage._country)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._point)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._code.isEmpty {
        try visitor.visitSingularStringField(value: _storage._code, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if !_storage._city.isEmpty {
        try visitor.visitSingularStringField(value: _storage._city, fieldNumber: 3)
      }
      if !_storage._country.isEmpty {
        try visitor.visitSingularStringField(value: _storage._country, fieldNumber: 4)
      }
      if let v = _storage._point {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Com_Infinite_Travllr_AirportDetails) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._code != other_storage._code {return false}
        if _storage._name != other_storage._name {return false}
        if _storage._city != other_storage._city {return false}
        if _storage._country != other_storage._country {return false}
        if _storage._point != other_storage._point {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Com_Infinite_Travllr_AirportLocationDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AirportLocationDetail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "coordinates"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.type)
      case 2: try decoder.decodeRepeatedDoubleField(value: &self.coordinates)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.coordinates.isEmpty {
      try visitor.visitPackedDoubleField(value: self.coordinates, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Com_Infinite_Travllr_AirportLocationDetail) -> Bool {
    if self.type != other.type {return false}
    if self.coordinates != other.coordinates {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Com_Infinite_Travllr_AirportInsertRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AirportInsertRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "countryCode"),
    2: .same(proto: "cityName"),
    3: .same(proto: "airports"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.countryCode)
      case 2: try decoder.decodeSingularStringField(value: &self.cityName)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.airports)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.countryCode.isEmpty {
      try visitor.visitSingularStringField(value: self.countryCode, fieldNumber: 1)
    }
    if !self.cityName.isEmpty {
      try visitor.visitSingularStringField(value: self.cityName, fieldNumber: 2)
    }
    if !self.airports.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.airports, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Com_Infinite_Travllr_AirportInsertRequest) -> Bool {
    if self.countryCode != other.countryCode {return false}
    if self.cityName != other.cityName {return false}
    if self.airports != other.airports {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Com_Infinite_Travllr_AirportInsertResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AirportInsertResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "response"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.response)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.response != false {
      try visitor.visitSingularBoolField(value: self.response, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Com_Infinite_Travllr_AirportInsertResponse) -> Bool {
    if self.response != other.response {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Com_Infinite_Travllr_CityLocationDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CityLocationDetail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "coordinates"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.type)
      case 2: try decoder.decodeRepeatedDoubleField(value: &self.coordinates)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.coordinates.isEmpty {
      try visitor.visitPackedDoubleField(value: self.coordinates, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Com_Infinite_Travllr_CityLocationDetail) -> Bool {
    if self.type != other.type {return false}
    if self.coordinates != other.coordinates {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Com_Infinite_Travllr_CityDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CityDetail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "country"),
    2: .same(proto: "name"),
    3: .same(proto: "point"),
    4: .same(proto: "airports"),
  ]

  fileprivate class _StorageClass {
    var _country: String = String()
    var _name: String = String()
    var _point: Com_Infinite_Travllr_CityLocationDetail? = nil
    var _airports: [Com_Infinite_Travllr_AirportDetails] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _country = source._country
      _name = source._name
      _point = source._point
      _airports = source._airports
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._country)
        case 2: try decoder.decodeSingularStringField(value: &_storage._name)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._point)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._airports)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._country.isEmpty {
        try visitor.visitSingularStringField(value: _storage._country, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if let v = _storage._point {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._airports.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._airports, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Com_Infinite_Travllr_CityDetail) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._country != other_storage._country {return false}
        if _storage._name != other_storage._name {return false}
        if _storage._point != other_storage._point {return false}
        if _storage._airports != other_storage._airports {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Com_Infinite_Travllr_CityListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CityListResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cities"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.cities)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cities.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cities, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  func _protobuf_generated_isEqualTo(other: Com_Infinite_Travllr_CityListResponse) -> Bool {
    if self.cities != other.cities {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
